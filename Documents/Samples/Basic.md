# 基本の使い方

あるクラスが別のクラスをコンストラクタで要求しているとき、
そこへオブジェクトを正しく与えるのは骨の折れる作業です。
Deprovgenでファクトリークラスを生成すると、コンストラクタに何を渡せばよいか判断してくれます。

このサンプルでのシナリオはあまり有用なものではありませんが、Deprovgenの働きの基本を確認することができます。

以下はユーザーコードです。

```csharp
using System;
using UseDeprovgen.Infra;
using Deprovgen.Annotations;

namespace UseDeprovgen.Samples.Basic
{
    // Clientクラスにこのクラスを注入したい
	class Service
	{
		public void Show()
		{
			Console.WriteLine("This is Service!");
		}
	}

    // Serviceクラスをこのクラスへ注入したい
	class Client
	{
		private readonly Service _service;

		public Client(Service service)
		{
			_service = service;
		}

		public void Execute()
		{
			Console.WriteLine("# Client");
			_service.Show();
		}
	}

    // ファクトリーの定義。これをタネにDeprovgenの生成を走らせます
	[Factory]
	interface IFactory
	{
		Client ResolveClient();
	}

	class BasicSample : ISample
	{
        // ファクトリーの利用側
		public void Run()
		{
            // Factory というクラスが生成されるのでこう書く
            // もちろん、Factoryクラスが生成されてから書いても良い
			var factory = new Factory(new Service());
			factory.ResolveClient().Execute();
			factory.Dispose();
		}
	}
}
```

生成されるコードは以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Basic
{
    internal partial class Factory : IFactory
        , IDisposable
    {
        private readonly Service _service;

        // 一度生成したオブジェクトを再利用するためのキャッシュ
        private Client? _ResolveClientCache;

        // 依存関係の解決に必要なオブジェクトはコンストラクタで渡す
        public Factory(Service service)
        {
            _service = service;
        }

        // このメソッドを呼べば、 Client クラスの依存関係が解決されて返される
        public Client ResolveClient()
        {
            // 生成したものをキャッシュしながら返す。
            // キャッシュしたものは、次に呼び出したときに再利用される
            return _ResolveClientCache ??= new Client(_service);
        }


        // キャッシュのうち破棄すべきものを破棄するメソッド(今回は破棄するものがない)
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下のようになります：

```
# Client
This is Service!
```

`BasicSample`クラスを見ての通り、ファクトリー自体に`Service`クラスのオブジェクトを与える必要があるため、
`Client`クラスを直接生成するよりむしろコーディングの負担が高くなってしまっています。

それでは困るので、この次のサンプルではコンストラクタに`Service`クラスのオブジェクトを渡さずに利用する方法を紹介します。
