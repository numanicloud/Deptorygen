# キャッシュできていることを確認

シングルトンパターンとして利用したいクラスは、ファクトリー内部にキャッシュして使いまわしてもらいたいと考えるでしょう。Deprovgenのファクトリーがオブジェクトを生成する場合、デフォルトでそのオブジェクトをキャッシュします。

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.UseCache
{
	// このクラスが依存関係解決時にキャッシュされているか確かめたい
	class Service
	{
		private static int NextId = 0;

		private int Id { get; }

		public Service()
		{
			Id = NextId++;
		}

		public void Invoke()
		{
			Console.WriteLine($"This is Service #{Id}.");
		}
	}

	class Client
	{
		private readonly Service _serviceA;
		private readonly Service _serviceB;

		public Client(Service serviceA, Service serviceB)
		{
			_serviceA = serviceA;
			_serviceB = serviceB;
		}

		public void Say()
		{
			// キャッシュされていれば、2つのオブジェクトは同じIDを表示するはず
			_serviceA.Invoke();
			_serviceB.Invoke();
		}
	}

	// ファクトリー定義
	[Factory]
	interface IFactory
	{
		// Serviceクラスをファクトリーに定義しておかないとコンストラクタで要求されてしまう
		// その場合キャッシュと同じ効果はあるが、ここでは定義した場合のキャッシュを確かめたい
		Service ResolveService();
		Client ResolveClient();
	}

	class UseCacheSample : ISample
	{
		public void Run()
		{
			var factory = new Factory();
			factory.ResolveClient().Say();
			factory.Dispose();
		}
	}
}
```

以下は生成されるコードです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.UseCache
{
    internal partial class Factory : IFactory
        , IDisposable
    {

        private Service? _ResolveServiceCache;
        private Client? _ResolveClientCache;

        public Factory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public Client ResolveClient()
        {
            return _ResolveClientCache ??= new Client(ResolveService(), ResolveService());
        }


        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
This is Service #0.
This is Service #0.
```

注意点としては、Factoryクラス自体を新たに生成した場合、新たなFactoryクラスからServiceクラスを取得したならば、
それはキャッシュから再利用されることはなく、新たにnewされます。
なぜなら、元々あったFactoryクラスのキャッシュ変数とはスコープが切り離されているからです。

そのような状況は以下のように再現できます:

1. `Factory`クラスをnewする。(`factory1`とする)
2. `factory1`を用いて`Service`を生成する。(`service1`とする)
3. 新たな`Factory`クラスをnewする。(`factory2`とする) 
4. `factory2`を用いて`Service`を生成する。(`service2`とする)
5. `service1`と`service2`は別のインスタンスである。つまり、`service2`はキャッシュから再利用されたインスタンスではない。

このことは、シングルトン的な振る舞いはあるが完全にそうではない、すなわち文脈に応じて別々に扱いたいようなオブジェクトに対して利用できます。

例えば、HTTPリクエストを処理するアプリケーションでは、
1つのリクエストの間においては常にアクセス可能で、しかしリクエストを処理し終われば破棄したいようなクラスを書くことがあり、
そういった場合にファクトリーのスコープの仕組みを利用できます。
