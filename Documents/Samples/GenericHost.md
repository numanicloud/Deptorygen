# GenericHostと連携する

GenericHostはMicrosoftが提供している汎用的なフレームワークです。

汎用的な機能の中にはDIコンテナが含まれていますが、このDIコンテナはどんな依存関係も動的に解決しようとします。
この方法は強力で、アセンブリから読み込まれている型であればどんな型の依存関係も解決することができます。
一方で、動的な解決ではインスタンスを生成する手順を確認することができず、また生成に時間がかかる場合があるなどのコストがあります。

Deprovgenでは、どんな依存関係も静的に解決しようとします。
しかし型どうしの依存関係は静的に解決できるものばかりではないため、動的なDIコンテナと併せて利用することをお勧めします。

Deprovgenでは、GenericHostによって依存関係の解決するときに、一部だけ静的に解決できるよう機能を拡張できます。

### サンプル

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using Deprovgen.GenericHost;
using Microsoft.Extensions.DependencyInjection;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.GenericHost
{
	class Service
	{
		public void Tell()
		{
			Console.WriteLine("Wow its Service!");
		}
	}

	class Service2
	{
		public void Describe()
		{
			Console.WriteLine("It is Service2.");
		}
	}

	class Client
	{
		private readonly Service _service;
		private readonly Service2 _service2;

		public Client(Service service, Service2 service2)
		{
			_service = service;
			_service2 = service2;
		}

		public void Work()
		{
			Console.WriteLine("# Client");
			_service.Tell();
			_service2.Describe();
		}
	}

	// ConfigureGenericHost 属性をつけると、GenericHostで使えるようになる
	[Factory]
	[ConfigureGenericHost]
	interface IFactory
	{
		Service ResolveService();
		Service2 ResolveService2();
		Client ResolveClient();
	}

	class GenericHostSample : ISample
	{
		public void Run()
		{
			var services = new ServiceCollection();

			// GenericHost の ServiceCollection インスタンスに、ファクトリーのインスタンスを登録する
			services.UseDeprovgenFactory(new Factory());

			var serviceProvider = services.BuildServiceProvider();

			// Factory クラスで解決できる依存関係が、ServiceProvider からも解決できるようになる
			serviceProvider.GetService<Client>().Work();
		}
	}
}
```

以下は生成されるコードです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;
using Deprovgen.GenericHost;
using Microsoft.Extensions.DependencyInjection;

namespace UseDeprovgen.Samples.GenericHost
{
    internal partial class Factory : IFactory
        , IDisposable
        , IDeprovgenFactory
    {

        private Service? _ResolveServiceCache;
        private Service2? _ResolveService2Cache;
        private Client? _ResolveClientCache;

        public Factory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public Service2 ResolveService2()
        {
            return _ResolveService2Cache ??= new Service2();
        }

        public Client ResolveClient()
        {
            return _ResolveClientCache ??= new Client(ResolveService(), ResolveService2());
        }


		// このメソッドで GenericHost に依存関係の解決方法を登録する
        public void ConfigureServices(IServiceCollection services)
        {
			// Transientとして登録しているが、
			// インスタンスをファクトリー側でキャッシュしているため、
			// ユーザーはキャッシュされたインスタンスを受け取ることができる
            services.AddTransient<Factory>(provider => this);
            services.AddTransient<Service>(provider => ResolveService());
            services.AddTransient<Service2>(provider => ResolveService2());
            services.AddTransient<Client>(provider => ResolveClient());
        }
        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
# Client
Wow its Service!
It is Service2.
```
