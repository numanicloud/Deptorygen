# Deprovgen サンプル集

## サンプルの読み方

以下のように定義された `ISample` クラスを利用します。
サンプルコードのエントリポイントとなるクラスは、 `ISample` を実装する必要があります。
これの`Run`メソッドが Main メソッドから呼ばれます。

```csharp
namespace UseDeprovgen.Infra
{
	interface ISample
	{
		void Run();
	}
}
```

また、生成されるコードとして紹介するプログラムにはコメントが入っている場合がありますが、これは実際に生成されるコードには入っていないコメントを紹介のために追加したものです。

## 基本の使い方

あるクラスが別のクラスをコンストラクタで要求しているとき、
そこへオブジェクトを正しく与えるのは骨の折れる作業です。
Deprovgenでファクトリークラスを生成すると、コンストラクタに何を渡せばよいか判断してくれます。

このサンプルでのシナリオはあまり有用なものではありませんが、Deprovgenの働きの基本を確認することができます。

以下はユーザーコードです。

```csharp
using System;
using UseDeprovgen.Infra;
using Deprovgen.Annotations;

namespace UseDeprovgen.Samples.Basic
{
    // Clientクラスにこのクラスを注入したい
	class Service
	{
		public void Show()
		{
			Console.WriteLine("This is Service!");
		}
	}

    // Serviceクラスをこのクラスへ注入したい
	class Client
	{
		private readonly Service _service;

		public Client(Service service)
		{
			_service = service;
		}

		public void Execute()
		{
			Console.WriteLine("# Client");
			_service.Show();
		}
	}

    // ファクトリーの定義。これをタネにDeprovgenの生成を走らせます
	[Factory]
	interface IFactory
	{
		Client ResolveClient();
	}

	class BasicSample : ISample
	{
        // ファクトリーの利用側
		public void Run()
		{
            // Factory というクラスが生成されるのでこう書く
            // もちろん、Factoryクラスが生成されてから書いても良い
			var factory = new Factory(new Service());
			factory.ResolveClient().Execute();
			factory.Dispose();
		}
	}
}
```

生成されるコードは以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Basic
{
    internal partial class Factory : IFactory
        , IDisposable
    {
        private readonly Service _service;

        // 一度生成したオブジェクトを再利用するためのキャッシュ
        private Client? _ResolveClientCache;

        // 依存関係の解決に必要なオブジェクトはコンストラクタで渡す
        public Factory(Service service)
        {
            _service = service;
        }

        // このメソッドを呼べば、 Client クラスの依存関係が解決されて返される
        public Client ResolveClient()
        {
            // 生成したものをキャッシュしながら返す。
            // キャッシュしたものは、次に呼び出したときに再利用される
            return _ResolveClientCache ??= new Client(_service);
        }


        // キャッシュのうち破棄すべきものを破棄するメソッド(今回は破棄するものがない)
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下のようになります：

```
# Client
This is Service!
```

`BasicSample`クラスを見ての通り、ファクトリー自体に`Service`クラスのオブジェクトを与える必要があるため、`Client`クラスを直接生成するよりむしろコーディングの負担が高くなってしまっています。しかしこの問題について不安に思う必要がない理由のひとつは、これは依存関係の規模が小さいからということです。

不安に思う必要がないもうひとつの理由は、ファクトリーのコンストラクタに`Service`クラスのオブジェクトを渡さずに利用する方法もあることです。

## 解決したいオブジェクトの依存先も解決したい

このサンプルでは、`Service`クラスの生成もファクトリーに任せることで、ユーザーは`Service`についても`Client`についても、そのクラスの生成方法について考える責任から解放されることができます。

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.BasicDependency
{
	class Service
	{
		public void Show()
		{
			Console.WriteLine("This is Service!");
		}
	}

	class Client
	{
		private readonly Service _service;

		public Client(Service service)
		{
			_service = service;
		}

		public void Execute()
		{
			Console.WriteLine("# Client");
			_service.Show();
		}
	}

	[Factory]
	interface IFactory
	{
        // Serviceクラスを解決してもらいたい
		Service ResolveService();
        // ClientクラスはServiceクラスに依存している。
        // これも解決してもらいたい
		Client ResolveClient();
	}

	class BasicDependencySample : ISample
	{
		public void Run()
		{
			// Factoryクラスのコンストラクタに引数がいらない
			var factory = new Factory();
			factory.ResolveClient().Execute();
			factory.Dispose();
		}
	}
}
```

生成されるコードは以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.BasicDependency
{
    internal partial class Factory : IFactory
        , IDisposable
    {

        private Service? _ResolveServiceCache;
        private Client? _ResolveClientCache;

        public Factory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public Client ResolveClient()
        {
            return _ResolveClientCache ??= new Client(ResolveService());
        }


        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
# Client
This is Service!
```

## キャッシュできていることを確認

シングルトンパターンとして利用したいクラスは、ファクトリー内部にキャッシュして使いまわしてもらいたいと考えるでしょう。Deprovgenのファクトリーがオブジェクトを生成する場合、デフォルトでそのオブジェクトをキャッシュします。

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.UseCache
{
	// このクラスが依存関係解決時にキャッシュされているか確かめたい
	class Service
	{
		private static int NextId = 0;

		private int Id { get; }

		public Service()
		{
			Id = NextId++;
		}

		public void Invoke()
		{
			Console.WriteLine($"This is Service #{Id}.");
		}
	}

	class Client
	{
		private readonly Service _serviceA;
		private readonly Service _serviceB;

		public Client(Service serviceA, Service serviceB)
		{
			_serviceA = serviceA;
			_serviceB = serviceB;
		}

		public void Say()
		{
			// キャッシュされていれば、2つのオブジェクトは同じIDを表示するはず
			_serviceA.Invoke();
			_serviceB.Invoke();
		}
	}

	// ファクトリー定義
	[Factory]
	interface IFactory
	{
		// Serviceクラスをファクトリーに定義しておかないとコンストラクタで要求されてしまう
		// その場合キャッシュと同じ効果はあるが、ここでは定義した場合のキャッシュを確かめたい
		Service ResolveService();
		Client ResolveClient();
	}

	class UseCacheSample : ISample
	{
		public void Run()
		{
			var factory = new Factory();
			factory.ResolveClient().Say();
			factory.Dispose();
		}
	}
}
```

以下は生成されるコードです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.UseCache
{
    internal partial class Factory : IFactory
        , IDisposable
    {

        private Service? _ResolveServiceCache;
        private Client? _ResolveClientCache;

        public Factory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public Client ResolveClient()
        {
            return _ResolveClientCache ??= new Client(ResolveService(), ResolveService());
        }


        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
This is Service #0.
This is Service #0.
```

注意点としては、Factoryクラス自体を新たに生成した場合、新たなFactoryクラスからServiceクラスを取得したならば、それはキャッシュから再利用されることはなく、新たにnewされます。なぜなら、元々あったFactoryクラスのキャッシュ変数とはスコープが切り離されているからです。

そのような状況は以下のように再現できます:

1. `Factory`クラスをnewする。(`factory1`とする)
2. `factory1`を用いて`Service`を生成する。(`service1`とする)
3. 新たな`Factory`クラスをnewする。(`factory2`とする) 
4. `factory2`を用いて`Service`を生成する。(`service2`とする)
5. `service1`と`service2`は別のインスタンスである。つまり、`service2`はキャッシュから再利用されたインスタンスではない。

このことは、シングルトン的な振る舞いはあるが完全にそうではない、すなわち文脈に応じて別々に扱いたいようなオブジェクトに対して利用できます。

例えば、HTTPリクエストを処理するアプリケーションでは、1つのリクエストの間においては常にアクセス可能で、しかしリクエストを処理し終われば破棄したいようなクラスを書くことがあり、そういった場合にファクトリーのスコープの仕組みを利用できます。

## 生成時にキャッシュしないようにしたい

ファクトリーから取得したいオブジェクトは、キャッシュしてほしいものばかりではありません。キャッシュを伴わずに依存関係を解決するオプションが用意されています。

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.Transient
{
	// このクラスが依存関係解決時にキャッシュされないことを確かめたい
	class Service
	{
		private static int NextId = 0;

		private int Id { get; }

		public Service()
		{
			Id = NextId++;
		}

		public void Invoke()
		{
			Console.WriteLine($"This is Service #{Id}.");
		}
	}

	class Client
	{
		private readonly Service _serviceA;
		private readonly Service _serviceB;

		public Client(Service serviceA, Service serviceB)
		{
			_serviceA = serviceA;
			_serviceB = serviceB;
		}

		public void Say()
		{
			// キャッシュされていなければ、2つのオブジェクトは互いに異なるIDを表示するはず
			_serviceA.Invoke();
			_serviceB.Invoke();
		}
	}

	// ファクトリー定義
	[Factory]
	interface IFactory
	{
		// 解決メソッドの名前の末尾を "AsTransient" にするとキャッシュしないようになる
		Service ResolveServiceAsTransient();
		Client ResolveClient();
	}

	class TransientSample : ISample
	{
		public void Run()
		{
			var factory = new Factory();
			factory.ResolveClient().Say();
			factory.Dispose();
		}
	}
}
```

以下は生成されるコードです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Transient
{
    internal partial class Factory : IFactory
        , IDisposable
    {

        private Client? _ResolveClientCache;

        public Factory()
        {
        }

        public Service ResolveServiceAsTransient()
        {
            return new Service();
        }

        public Client ResolveClient()
        {
            return _ResolveClientCache ??= new Client(ResolveServiceAsTransient(), ResolveServiceAsTransient());
        }


        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
This is Service #0.
This is Service #1.
```

キャッシュするかどうかを、解決メソッドに対して属性を書くことで指定したい場合もあるかと思いますが、メソッド名はファクトリーを使用するプログラマーにとって重要であり、キャッシュをするのかどうかは常に名前から判別できるようDeprovgenは強制しています。

この機能が備わっている都合上、名前の末尾が `AsTransient` であるようなクラスの解決メソッドを定義したい場合、 `ResolveXXXAsTransientInstance` などというように `AsTransient` の後に別の文字を足さない限り、クラスはキャッシュしないものとしてコード生成が実行されてしまいますのでご注意ください。

## ファクトリーが自動で依存先クラスを生成する範囲をカスタマイズする

クライアントクラスに必要な依存先クラスが2つ以上あるとき、ファクトリーがその依存先を全て自分で生成することはできないとしても、自分で生成できるものまでコンストラクタを通じて要求してしまうのは望ましくありません。

なので、Deprovgenで生成したファクトリーは全ての依存先ではなく、自分では生成できない依存先のみをコンストラクタを通じて要求します。

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.AutoAndManual
{
	// こちらはファクトリーで生成してもらう予定
	class ServiceSilver
	{
		public void Tell()
		{
			Console.WriteLine("I'm Silver.");
		}
	}

	// こちらはファクトリー外で自前で生成する予定
	class ServiceGold
	{
		public void Say()
		{
			Console.WriteLine("I'm Gold.");
		}
	}

	class Client
	{
		private readonly ServiceSilver _silver;
		private readonly ServiceGold _gold;

		public Client(ServiceSilver silver, ServiceGold gold)
		{
			_silver = silver;
			_gold = gold;
		}

		public void Invoke()
		{
			Console.WriteLine("# Client");
			_silver.Tell();
			_gold.Say();
		}
	}

	[Factory]
	interface IFactory
	{
		ServiceSilver ResolveServiceSilver();
		Client ResolveClient();
	}

	class AutoAndManualSample : ISample
	{
		public void Run()
		{
			var factory = new Factory(new ServiceGold());
			factory.ResolveClient().Invoke();
			factory.Dispose();
		}
	}
}
```

以下は生成されるコードです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.AutoAndManual
{
    internal partial class Factory : IFactory
        , IDisposable
    {
        private readonly ServiceGold _serviceGold;

        private ServiceSilver? _ResolveServiceSilverCache;
        private Client? _ResolveClientCache;

        public Factory(ServiceGold serviceGold)
        {
            _serviceGold = serviceGold;
        }

        public ServiceSilver ResolveServiceSilver()
        {
            return _ResolveServiceSilverCache ??= new ServiceSilver();
        }

        public Client ResolveClient()
        {
            return _ResolveClientCache ??= new Client(ResolveServiceSilver(), _serviceGold);
        }


        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
# Client
I'm Silver.
I'm Gold.
```

`Factory`クラスのコンストラクタでは`ServiceGold`クラスのオブジェクトだけが要求され、一方で`ServiceSilver`クラスのオブジェクトはファクトリー自身が必要に応じて生成します。

これは、`IFactory`インターフェースとして書かれたファクトリー定義の中に`ServiceSilver`を取得するためのメソッドが含まれているためです。`ServiceGold`を取得するためのメソッドも用意したならば、`Factory`クラスのコンストラクタは引数が0個となります。

## 解決メソッドに直接オブジェクトを渡す

依存関係を解決したいクラスのコンストラクタに、それを生成する直前まで入手できないようなデータを与えたい場合があります。その場合、ファクトリー定義内の解決メソッドに引数を与えることができます。

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.Parameterize
{
	class Service
	{
		public void Say()
		{
			Console.WriteLine("It's Service!");
		}
	}

	class Client
	{
		private readonly Service _service;
		private readonly int _repeat;

		public Client(Service service, int repeat)
		{
			_service = service;
			_repeat = repeat;
		}

		public void Run()
		{
			Console.WriteLine("# Client");
			for (int i = 0; i < _repeat; i++)
			{
				_service.Say();
			}
		}
	}

	[Factory]
	interface IFactory
	{
		Service ResolveService();
		Client ResolveClient(int repeat);
	}

	class ParameterizeSample : ISample
	{
		public void Run()
		{
			var factory = new Factory();
			factory.ResolveClient(4).Run();
			factory.Dispose();
		}
	}
}
```

以下は生成されるコードです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Parameterize
{
    internal partial class Factory : IFactory
        , IDisposable
    {

        private Service? _ResolveServiceCache;
        private Client? _ResolveClientCache;

        public Factory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public Client ResolveClient(Int32 repeat)
        {
            return _ResolveClientCache ??= new Client(ResolveService(), repeat);
        }


        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
# Client
It's Service!
It's Service!
It's Service!
It's Service!
```

## (没)特定のファクトリーをベースにして新しいファクトリーを生成する

アプリが開始してから最初にファクトリーを生成するまでに、アプリの実行に必要な全ての情報が揃うことはあまりありません。
例えば、ユーザーがコマンドを入力した瞬間にそのコマンドを実行するようなアプリについて考えると、コマンドを入力されるまでは「ユーザーがどのコマンドを選ぼうとしているか」の情報を得ることができないはずです。

そのため、最初に生成したファクトリーだけではアプリで必要な依存関係を全て解決できない可能性があります。

そこで、特定のファクトリーによって解決できるオブジェクトや、ファクトリーが解決のために利用するオブジェクトを引き継いだ新たなファクトリーを生成することができます。
この機能は、アプリの実行中のある時点で新たな情報が収集できたタイミングに、新たな依存関係を解決できるよう新たなファクトリーをセットアップする目的に用います。

以下はユーザーの書くコードです。

* `ClientA` クラスは `Service` クラスを必要とします。
* `ClientB` クラスは `Service` クラス、 `Service2` クラスを両方とも必要とします。
* `IFactoryA` の実装クラスをnewするタイミングでは、 `Service2` を生成できるだけの情報が集まっていません。そこで、 `Service2` クラスを生成するための情報が集まった際に `IFactoryB` の実装クラスを新たにnewします。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.FactoryProvider
{
	class Service
	{
		public void Say()
		{
			Console.WriteLine("This is Service");
		}
	}

	class Service2
	{
		public void Tell()
		{
			Console.WriteLine("This is Service 2");
		}
	}

	class ClientA
	{
		private readonly Service _service;

		public ClientA(Service service)
		{
			_service = service;
		}

		public void Execute()
		{
			Console.WriteLine("# ClientA");
			_service.Say();
		}
	}

	class ClientB
	{
		private readonly Service _service;
		private readonly Service2 _service2;

		public ClientB(Service service, Service2 service2)
		{
			_service = service;
			_service2 = service2;
		}

		public void Invoke()
		{
			Console.WriteLine("# ClientB");
			_service.Say();
			_service2.Tell();
		}
	}

	// ベースとなるファクトリー
	// 派生先のファクトリーの情報をこちらに書く
	// FactoryB クラスは生成されるコードなので、一度 IFactoryB をコード生成してか書く必要がある
	[Factory]
	[FactoryProvider(typeof(FactoryB))]
	interface IFactoryA
	{
		ClientA ResolveClientA();
	}

	// 派生したファクトリー
	// ベースとなるファクトリーが居なくても利用できるコードが生成される
	[Factory]
	interface IFactoryB
	{
		ClientB ResolveClientB();
	}

	class FactoryProviderSample : ISample
	{
		public void Run()
		{
			// 最初のファクトリーを生成する
			var factory = new FactoryA(new Service());
			factory.ResolveClientA().Execute();

			// サンプルコードなので、 Service2 クラスをnewできるだけの情報が集まった状況を仮定して Service2 を作成する
			var service2 = new Service2();

			// 最初のファクトリーの設定を受け継いで、新しいファクトリーを生成する
			var factoryB = factory.ResolveFactoryB(service2);
			factoryB.ResolveClientB().Invoke();
		}
	}
}
```

生成されるコード `FactoryA.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.FactoryProvider
{
    internal partial class FactoryA : IFactoryA
    {
        private readonly Service _service;

        private ClientA? _resolveClientACache;

        public FactoryA(Service service)
        {
            _service = service;
        }

        public ClientA ResolveClientA()
        {
            return _resolveClientACache ??= new ClientA(_service);
        }

        public FactoryB ResolveFactoryB(Service2 service2)
        {
            return new FactoryB(_service, service2);
        }
    }

    internal static class FactoryAExtensions
    {
        public static FactoryB ResolveFactoryB(this IFactoryA self, Service2 service2)
        {
            return self is FactoryA concrete ? concrete.ResolveFactoryB(service2)
                : throw new NotImplementedException("このメソッドは FactoryA クラスに対してのみ呼び出せます。");
        }
    }
}
```

生成されるコード `FactoryB.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;

namespace UseDeprovgen.Samples.FactoryProvider
{
    internal partial class FactoryB : IFactoryB
    {
        private readonly Service _service;
        private readonly Service2 _service2;

        private ClientB? _resolveClientBCache;

        public FactoryB(Service service, Service2 service2)
        {
            _service = service;
            _service2 = service2;
        }

        public ClientB ResolveClientB()
        {
            return _resolveClientBCache ??= new ClientB(_service, _service2);
        }
    }

}
```

実行結果は以下の通りです。

```
# ClientA
This is Service
# ClientB
This is Service
This is Service 2
```

このサンプルでは、`FactoryA`が生成されるタイミングでは生成できないクラス`Service2`を、別のファクトリークラス`FactoryB`に生成させることにしました。

ただし、`FactoryB`を生成するときに`Service`クラスのインスタンスを改めて与えるのは冗長であるため、既に準備できている依存先のオブジェクトは`FactoryA`クラスのフィールドから引き継いでいます。

### 課題

サービスとしてオブジェクトを引数を通じて受け渡すと、受け渡したサービスは派生先のファクトリーではキャッシュされたもののように振る舞います。
しかし、そのオブジェクトが基となったファクトリーではTransientな解決メソッドで生成されていた場合、これは問題になります。キャッシュされていないと思っていたオブジェクトが実はキャッシュされている可能性があるためです。

これに対処する仕様として考えられる方法がいくつかあります。

#### ファクトリー定義の取り込みを利用する

後述の「他のファクトリー定義を取り込む」を利用すると、基となったファクトリーで解決できるようなものを、派生先のファクトリーが自分自身で解決するようになります。

これを利用しなければならないことが許容できるならば、Deprovgen側で追加の機能を用意する必要はありません。

#### 基底ファクトリーをコンストラクタで注入する

派生先のファクトリーのコンストラクタを通じて、基となるファクトリー自体を受け渡します。このファクトリーの解決メソッドを利用して、派生先のファクトリーが依存先を入手します。

これは生成されるクラスの構造が少々複雑になる、そしてユーザーが手動でnewしてファクトリーを利用したい場合に基となるファクトリーも全て手動で生成しなければならないなどのリスクがあります。特に後者のシナリオでは、基となるファクトリーからの依存先が派生先のファクトリーで全て必要になるわけではない場合に冗長です。

## 他のファクトリー定義を取り込む(ミックスイン)

以下のような2つのインターフェースがあったとします。

```csharp
interface IFactoryX
{
	Service ResolveService();
	ClientA ResolveClientA();
}

interface IFactoryY
{
	Service ResolveService();
	ClientA ResolveClientA();
	Service2 ResolveService2();
	ClientB ResolveClientB();	
}
```

`IFactoryY`インターフェースは、`IFactoryX`インターフェースに定義されているメソッドを全て含んでいます。このような場合C#では、以下のようにインターフェースがインターフェースを継承するような形で定義することが多いです。

```csharp
interface IFactoryY : IFactoryX
{
	// IFactoryY インターフェースで特有のメソッドだけを定義する
	Service2 ResolveService2();
	ClientB ResolveClientB();
}
```

Deprovgenではこの書き方をファクトリー定義に利用することができます。要するに、インターフェースを実装するときは通常その基底インターフェースも考慮する必要があるので、Deprovgenの生成するファクトリーもそうするということです。

### サンプル

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.Mixin
{
	class Service
	{
		public void Tell()
		{
			Console.WriteLine("Its Service.");
		}
	}

	class Service2
	{
		public void Say()
		{
			Console.WriteLine("That's Service2!");
		}
	}

	class ClientA
	{
		private readonly Service _service;

		public ClientA(Service service)
		{
			_service = service;
		}

		public void Invoke()
		{
			Console.WriteLine("# ClientA");
			_service.Tell();
		}
	}

	class ClientB
	{
		private readonly Service2 _service2;

		public ClientB(Service2 service2)
		{
			_service2 = service2;
		}

		public void Execute()
		{
			Console.WriteLine("# ClientB");
			_service2.Say();
		}
	}

	[Factory]
	interface IBaseFactory
	{
		Service ResolveService();
		ClientA ResolveClientA();
	}

	// このインターフェースは、IBaseFactoryインターフェースの定義するメソッドも含む
	[Factory]
	interface IMixinFactory : IBaseFactory
	{
		Service2 ResolveService2();
		ClientB ResolveClientB();
	}

	class MixinSample : ISample
	{
		public void Run()
		{
			var baseFactory = new BaseFactory();
			baseFactory.ResolveClientA().Invoke();
			baseFactory.Dispose();

			// 生成されたMixinFactoryは、生成されたBaseFactoryの機能も持つ
			var mixinFactory = new MixinFactory();
			mixinFactory.ResolveClientA().Invoke();
			mixinFactory.ResolveClientB().Execute();
			mixinFactory.Dispose();
		}
	}
}
```

生成される `BaseFactory.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Mixin
{
    internal partial class BaseFactory : IBaseFactory
        , IDisposable
    {

        private Service? _ResolveServiceCache;
        private ClientA? _ResolveClientACache;

        public BaseFactory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public ClientA ResolveClientA()
        {
            return _ResolveClientACache ??= new ClientA(ResolveService());
        }


        
        public void Dispose()
        {
        }
    }
}
```

生成される `MixinFactory.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Mixin
{
    internal partial class MixinFactory : IMixinFactory
        , IDisposable
    {

        private Service2? _ResolveService2Cache;
        private ClientB? _ResolveClientBCache;
        private Service? _ResolveServiceCache;
        private ClientA? _ResolveClientACache;

        public MixinFactory()
        {
        }

        public Service2 ResolveService2()
        {
            return _ResolveService2Cache ??= new Service2();
        }

        public ClientB ResolveClientB()
        {
            return _ResolveClientBCache ??= new ClientB(ResolveService2());
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public ClientA ResolveClientA()
        {
            return _ResolveClientACache ??= new ClientA(ResolveService());
        }


        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
# ClientA
Its Service.
# ClientA
Its Service.
# ClientB
That's Service2!
```

## 依存関係の解決に別のファクトリーも利用する(キャプチャ)

別のファクトリーをプロパティとして持たせ、ファクトリーが依存関係を解決する際にプロパティに持っているファクトリーに解決を委譲することができます。

この機能は例えば、特定のファクトリーをインスタンス化する際にアプリ内の全ての依存関係を解決するだけの情報が収集できない場合などに便利です。

新たな情報が収集できたタイミングで新たなファクトリーをインスタンス化し、
その新たなファクトリーが元のファクトリーをプロパティとして持つようにすれば、
元のファクトリーが保持しているキャッシュなども引き継ぐことができます。

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.Capture
{
	class Service
	{
		public void Call()
		{
			Console.WriteLine("Its Service.");
		}
	}

	class Service2
	{
		public void Say()
		{
			Console.WriteLine("Its Service2!");
		}
	}

	class Client
	{
		private readonly Service _service;
		private readonly Service2 _service2;

		public Client(Service service, Service2 service2)
		{
			_service = service;
			_service2 = service2;
		}

		public void Run()
		{
			Console.WriteLine("# Client");
			_service.Call();
			_service2.Say();
		}
	}

	[Factory]
	interface IBaseFactory
	{
		Service ResolveService();
		[Resolution(typeof(CaptureFactory))]
		ICaptureFactory ResolveCaptureFactory(Service2 service2);
	}

	[Factory]
	interface ICaptureFactory
	{
		// ここでファクトリー定義の IBaseFactory を"キャプチャ"する
		IBaseFactory BaseFactory { get; }
		Client ResolveClient();
	}

	class CaptureSample : ISample
	{
		public void Run()
		{
			var baseFactory = new BaseFactory();
			baseFactory.ResolveCaptureFactory(new Service2())
				.ResolveClient()
				.Run();;
		}
	}
}
```

生成されるソースコード `BaseFactory.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Capture
{
    internal partial class BaseFactory : IBaseFactory
        , IDisposable
    {

        private Service? _ResolveServiceCache;
        private CaptureFactory? _ResolveCaptureFactoryCache;

        public BaseFactory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public ICaptureFactory ResolveCaptureFactory(Service2 service2)
        {
            return _ResolveCaptureFactoryCache ??= new CaptureFactory(service2, this);
        }


        
        public void Dispose()
        {
			// ファクトリーは常に IDisposable なので、破棄するためのコードが生成される
            _ResolveCaptureFactoryCache?.Dispose();
        }
    }
}
```

生成されるソースコード `CaptureFactory.g.cs` は以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Capture
{
    internal partial class CaptureFactory : ICaptureFactory
        , IDisposable
    {
        private readonly Service2 _service2;
        public IBaseFactory BaseFactory { get; }

        private Client? _ResolveClientCache;

        public CaptureFactory(Service2 service2, IBaseFactory baseFactory)
        {
            _service2 = service2;
            BaseFactory = baseFactory;
        }

        public Client ResolveClient()
        {
            return _ResolveClientCache ??= new Client(BaseFactory.ResolveService(), _service2);
        }


        
        public void Dispose()
        {
        }
    }
}
```

`CaptureFactory.ResolveService`メソッドにて、`Client`クラスを解決するために`Service`クラスが必要ですが、
そこを`IBaseFactory`インターフェースの持つメソッドを利用して解決しています。

実行結果は以下の通りです。

```
# Client
Its Service.
Its Service2!
```

キャプチャを用いると、必要なファクトリー インターフェースは生成されたクラスのコンストラクタの引数として要求されます。

そのため、コンストラクタの引数にCodeFixで生成されたクラスではなく`IBaseFactory`を実装した自作のクラスを渡すこともできます。
キャプチャをそのように利用すると、インスタンスを生成する手順をカスタマイズすることができます。

## ミックスインとキャプチャを組み合わせる

前のいくつかの節で紹介した「特定のファクトリーをベースにして他のファクトリーを生成する」機能と「他のファクトリーの定義を取り込む」機能を組み合わせて使うことをお勧めします。

以下はユーザーの書くコードです。

```csharp
using Deprovgen.Annotations;
using System;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.CaptureMixin
{
	class Service
	{
		public void Write()
		{
			Console.WriteLine("It's Service!");
		}
	}

	class Client
	{
		private readonly Service _service;

		public Client(Service service)
		{
			_service = service;
		}

		public void Invoke()
		{
			Console.WriteLine("# Client");
			_service.Write();
		}
	}

	[Factory]
	interface IBaseFactory
	{
		Service ResolveService();
		[Resolution(typeof(CaptureFactory))]
		ICaptureFactory ResolveCaptureFactory();
	}

	[Factory]
	interface ICaptureFactory : IBaseFactory
	{
		IBaseFactory BaseFactory { get; }
		Client ResolveClient();
	}

	class CaptureMixinSample : ISample
	{
		public void Run()
		{
			var baseFactory = new BaseFactory();
			baseFactory.ResolveCaptureFactory()
				.ResolveClient()
				.Invoke();
		}
	}
}
```

生成されるソースコード`BaseFactory.g.cs`は以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.CaptureMixin
{
    internal partial class BaseFactory : IBaseFactory
        , IDisposable
    {

        private Service? _ResolveServiceCache;
        private CaptureFactory? _ResolveCaptureFactoryCache;

        public BaseFactory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public ICaptureFactory ResolveCaptureFactory()
        {
            return _ResolveCaptureFactoryCache ??= new CaptureFactory(this);
        }


        
        public void Dispose()
        {
            _ResolveCaptureFactoryCache?.Dispose();
        }
    }
}
```

生成されるソースコード`CaptureFactory.g.cs`は以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.CaptureMixin
{
    internal partial class CaptureFactory : ICaptureFactory
        , IDisposable
    {
        public IBaseFactory BaseFactory { get; }

        private Client? _ResolveClientCache;

        public CaptureFactory(IBaseFactory baseFactory)
        {
            BaseFactory = baseFactory;
        }

        public Client ResolveClient()
        {
            return _ResolveClientCache ??= new Client(ResolveService());
        }

        public Service ResolveService()
        {
            return BaseFactory.ResolveService();
        }

        public ICaptureFactory ResolveCaptureFactory()
        {
            return BaseFactory.ResolveCaptureFactory();
        }


        
        public void Dispose()
        {
        }
    }
}
```

生成された`CaptureFactory`クラスには、`IBaseFactory`インターフェースにあったメソッドが実装されています。
そして、そうしたメソッド群を実装するためにキャプチャしたファクトリー`IBaseFactory`に解決を委譲しています。

実行結果は以下の通りです。

```
# Client
It's Service!
```

これらの機能を組み合わせて、ファクトリーの間に継承関係のようなものを作ることができます。
`CaptureFactory`は`BaseFactory`と同じインターフェースを`IBaseFactory`実装しており、
かつ`IBaseFactory`インターフェースの実装のために`BaseFactory`クラスのメソッドを利用しています。

## GenericHostと連携する

GenericHostはMicrosoftが提供している汎用的なフレームワークです。

汎用的な機能の中にはDIコンテナが含まれていますが、このDIコンテナはどんな依存関係も動的に解決しようとします。この方法は強力で、アセンブリから読み込まれている型であればどんな型の依存関係も解決することができます。

Deprovgenでは、どんな依存関係も静的に解決しようとします。しかし型どうしの依存関係は静的に解決できるものばかりではないため、動的なDIコンテナと併せて利用することをお勧めします。

Deprovgenでは、GenericHostによって依存関係の解決するときに、一部だけ静的に解決できるよう機能を拡張できます。

### サンプル

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using Deprovgen.GenericHost;
using Microsoft.Extensions.DependencyInjection;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.GenericHost
{
	class Service
	{
		public void Tell()
		{
			Console.WriteLine("Wow its Service!");
		}
	}

	class Service2
	{
		public void Describe()
		{
			Console.WriteLine("It is Service2.");
		}
	}

	class Client
	{
		private readonly Service _service;
		private readonly Service2 _service2;

		public Client(Service service, Service2 service2)
		{
			_service = service;
			_service2 = service2;
		}

		public void Work()
		{
			Console.WriteLine("# Client");
			_service.Tell();
			_service2.Describe();
		}
	}

	// ConfigureGenericHost 属性をつけると、GenericHostで使えるようになる
	[Factory]
	[ConfigureGenericHost]
	interface IFactory
	{
		Service ResolveService();
		Service2 ResolveService2();
		Client ResolveClient();
	}

	class GenericHostSample : ISample
	{
		public void Run()
		{
			var services = new ServiceCollection();

			// GenericHost の ServiceCollection インスタンスに、ファクトリーのインスタンスを登録する
			services.UseDeprovgenFactory(new Factory());

			var serviceProvider = services.BuildServiceProvider();

			// Factory クラスで解決できる依存関係が、ServiceProvider からも解決できるようになる
			serviceProvider.GetService<Client>().Work();
		}
	}
}
```

以下は生成されるコードです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;
using Deprovgen.GenericHost;
using Microsoft.Extensions.DependencyInjection;

namespace UseDeprovgen.Samples.GenericHost
{
    internal partial class Factory : IFactory
        , IDisposable
        , IDeprovgenFactory
    {

        private Service? _ResolveServiceCache;
        private Service2? _ResolveService2Cache;
        private Client? _ResolveClientCache;

        public Factory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }

        public Service2 ResolveService2()
        {
            return _ResolveService2Cache ??= new Service2();
        }

        public Client ResolveClient()
        {
            return _ResolveClientCache ??= new Client(ResolveService(), ResolveService2());
        }


		// このメソッドで GenericHost に依存関係の解決方法を登録する
        public void ConfigureServices(IServiceCollection services)
        {
			// Transientとして登録しているが、
			// インスタンスをファクトリー側でキャッシュしているため、
			// ユーザーはキャッシュされたインスタンスを受け取ることができる
            services.AddTransient<Factory>(provider => this);
            services.AddTransient<Service>(provider => ResolveService());
            services.AddTransient<Service2>(provider => ResolveService2());
            services.AddTransient<Client>(provider => ResolveClient());
        }
        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
# Client
Wow its Service!
It is Service2.
```

## ファクトリー自体のアクセシビリティを制御する

ファクトリーが生成するクラスが全て `public` アクセシビリティを持つ型である場合に限り、生成されるファクトリークラス自体も `public` アクセシビリティを持って生成されます。
それ以外の場合は、ファクトリークラスは `internal` アクセシビリティを持ちます。

ちなみに、ファクトリークラスを別のクラスにネストした型として生成する手段はサポートされていないため、アクセシビリティとしても `private` などが付くことはありません。

## コレクションに対してインスタンスを注入する

以下はユーザーの書くコードです。

```csharp
using System;
using System.Collections.Generic;
using System.Text;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.Collection
{
	abstract class Service
	{
		public abstract void Do();
	}

	class ServiceA : Service
	{
		public override void Do()
		{
			Console.WriteLine("This is ServiceA");
		}
	}

	class ServiceB : Service
	{
		public override void Do()
		{
			Console.WriteLine("This is ServiceB");
		}
	}

	class ServiceC : Service
	{
		public override void Do()
		{
			Console.WriteLine("This is ServiceC");
		}
	}

	class Client
	{
		private readonly IEnumerable<Service> _services;

		public Client(IEnumerable<Service> services)
		{
			_services = services;
		}

		public void Invoke()
		{
			Console.WriteLine("# Client");
			foreach (var service in _services)
			{
				service.Do();
			}
		}
	}

	[Factory]
	interface IFactory
	{
		ServiceA ResolveServiceA();
		ServiceB ResolveServiceB();
		ServiceC ResolveServiceC();
		[Resolution(typeof(ServiceA))]
		[Resolution(typeof(ServiceB))]
		[Resolution(typeof(ServiceC))]
		IEnumerable<Service> ResolveServices();
		Client ResolveClient();
	}

	class CollectionSample : ISample
	{
		public void Run()
		{
			var factory = new Factory();
			factory.ResolveClient().Invoke();
		}
	}
}
```

生成されるソースコードは以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Collection
{
    internal partial class Factory : IFactory
        , IDisposable
    {

        private ServiceA? _ResolveServiceACache;
        private ServiceB? _ResolveServiceBCache;
        private ServiceC? _ResolveServiceCCache;
        private Client? _ResolveClientCache;

        public Factory()
        {
        }

        public ServiceA ResolveServiceA()
        {
            return _ResolveServiceACache ??= new ServiceA();
        }

        public ServiceB ResolveServiceB()
        {
            return _ResolveServiceBCache ??= new ServiceB();
        }

        public ServiceC ResolveServiceC()
        {
            return _ResolveServiceCCache ??= new ServiceC();
        }

        public Client ResolveClient()
        {
            return _ResolveClientCache ??= new Client(ResolveServices());
        }

        public IEnumerable<Service> ResolveServices()
        {
            return new Service[]
            {
                ResolveServiceA(),
				ResolveServiceB(),
				ResolveServiceC()
            };
        }

        
        public void Dispose()
        {
        }
    }
}
```

実行結果は以下の通りです。

```
# Client
This is ServiceA
This is ServiceB
This is ServiceC
```

### 課題

依存関係を解決できない場合にコンストラクタの引数としてインスタンスを要求すべき

コレクションに注入するための記述が冗長？
一般的なDIコンテナではひとつの抽象に対して複数の具象を注入したように書ける。
以下のような感じ

```csharp
interface IFactory
{
	[Resolution(typeof(ServiceB))]
	[Resolution(typeof(ServiceA))]
	[Resolution(typeof(ServiceC))]
	IService ResolveService();
	Client ResolveClient();
}
```

## IDisposableなインスタンスが破棄されることを確認する

以下はユーザーの書くコードです。

```csharp
using System;
using Deprovgen.Annotations;
using UseDeprovgen.Infra;

namespace UseDeprovgen.Samples.Disposable
{
	class Service : IDisposable
	{
		public void Work()
		{
			Console.WriteLine("Hi its Service.");
		}

		public void Dispose()
		{
			Console.WriteLine("Disposed.");
		}
	}

	[Factory]
	interface IFactory
	{
		Service ResolveService();
	}

	class DisposableSample : ISample
	{
		public void Run()
		{
			Console.WriteLine("# Factory1");
			var factory = new Factory();
			factory.ResolveService().Work();
			factory.Dispose();

			Console.WriteLine("# Factory2");
			var factory2 = new Factory();
			factory2.Dispose();
		}
	}
}
```

生成されるソースコードは以下の通りです。

```csharp
// <autogenerated />
using System;
using System.Collections.Generic;

namespace UseDeprovgen.Samples.Disposable
{
    internal partial class Factory : IFactory
        , IDisposable
    {

        private Service? _ResolveServiceCache;

        public Factory()
        {
        }

        public Service ResolveService()
        {
            return _ResolveServiceCache ??= new Service();
        }


        
        public void Dispose()
        {
            _ResolveServiceCache?.Dispose();
        }
    }
}
```

`Factory.Dispose`メソッドで、キャッシュとして保持している`Service`インスタンスをDisposeします。
キャッシュなので、ファクトリーを通じて一度もインスタンスが生成されていない場合は何も起こりません。

実行結果は以下の通りです。

```
# Factory1
Hi its Service.
Disposed.
# Factory2
```

## インターフェースに対して具象クラスでもって解決する

# Deprovgenに欲しい機能

## IEnumerable&lt;T> に対する注入

以下のようにして、解決可能なすべてのクラスを含むコレクションを取得できるようにしたい

```csharp
[Factory]
interface IFactory
{
	[Implementation(typeof(HogeSilver))]
	[Implementation(typeof(HogeGold))]
	IEnumerable<IHoge> ResolveHogeCollection();
}
```

戻り値が `IEnumerable<TInterface>` であり、かつ `Resolution` 属性が付与されていて、
`Resolution` 属性の引数に渡された型が `TInterface` を継承あるいは実装していれば
複数のオブジェクトのコレクションとして `IEnumerable<TInterface>` を生成する。
その際、配列を用いる。

## 抽象クラスに対して具象クラスを注入

現在、戻り値の型はインターフェースまたは具象クラスを想定している。

抽象クラスに具象クラスを注入するのも問題ないか？

## 生成方法のカスタマイズ

GenericHostの、ラムダ式に生成方法を記述する形式の登録方法のように、ユーザーが生成方法をカスタマイズできる手段が欲しい

どのような場面で使いたくなるかは検証しておくべき

ファクトリー定義インターフェースをコンストラクタを通じて注入することで、注入されたクラスがそのファクトリーの解決メソッドも活用して自身の依存関係解決を行うようにする？
そうすると、前述のFactoryProviderにおけるキャッシュ問題も解決され、生成方法のカスタマイズにも使えるかも（Code Fixを用いず、ユーザーが自由にファクトリーを実装して渡せばよい）

定義は以下のようになる？

```csharp
[FactoryProvider(typeof(DerivedFactory))]
interface IBaseFactory
{
}

[CaptureFactory(typeof(IBaseFactory))]
interface IDerivedFactory
{
}

// 生成結果
class DerivedFactory
{
	// baseFactoryのところに対して、BaseFactoryからthisが渡されてくる
	public DerivedFactory(IBaseFactory baseFactory)
	{
	}
}
```

||FactoryProvider + Mixin|ファクトリー定義の注入|
|-|-|-|
|キャッシュ問題|問題なし|問題なし|
|記述量|属性1 + 継承1|属性2|
|手動での生成のしやすさ|しやすい|しづらい|
|基となるファクトリーの解決メソッド|**継承する**|継承しない|
|解決方法のカスタマイズ|できない|**できる**|
|生成コードをアノテーションに用いる|用いる|用いる|

この手のカスタマイズは、Deprovgenでやりたいシナリオを「Deprovgenの機能を他者が使う」と「他者の機能をDeprovgenが使う」に分けたうちの後者なのかもしれない。
すなわち、ファクトリーを注入できるようにすればあらゆるカスタマイズができ、例えばGenericHostに依存関係を部分的に解決してもらうことなどもできる。

### ファクトリーのキャプチャ再考

ファクトリーのキャプチャがResolverと異なるところは、ファクトリーを生成するために追加で必要な依存先をコンストラクタで要求しないことである。

```csharp
class BaseFactory
{
	// DerivedFactory の生成には Service2 が必要だが、ここでは要求しない
	public BaseFactory(Service1 service1)
	{
	}

	// DerivedFactory を生成できるようになるために、引数リストもコード生成している
	public DerivedFactory GetDerivedFactory(Service2 service2)
	{
		return new DerivedFactory(_service1, service2);
	}
}
```

この方式には問題点がある：

* GetDerivedFactory メソッドの引数リストがコード生成まで定まらない。そのため、ファクトリー定義に書くことができず属性で指定する必要がある。

これを、ファクトリーを生成するためのファクトリー定義を通常の解決メソッドと同じ書き方にしてしまうとよいかもしれない。

```csharp
[Factory]
interface IBaseFactory
{
	Client ResolveClient();
	[Resolution(typeof(DerivedFactory))]
	IDerivedFactory GetDerivedFactory();
}
```

以下のように生成される。

```csharp
class BaseFactory
{
	public BaseFactory(Service2 service2) { /* ... */ }
	public Client ResolveClient() { /* キャッシュしながら生成 */ }
	public IDerivedFactory GetDerivedFactory()
	{
		return new DerivedFactory(this, _service2);
	} 
}
```

これでは困る部分があるが、それが仕様である。
困る部分とは、コンストラクタで`Service2`を要求してしまっていることであるが、標準の機能でこれは回避できる。ファクトリー定義で、手動で引数リストを書くのだ。

```csharp
[Factory]
interface IBaseFactory
{
	[Resolution(typeof(DerivedFactory))]
	IDerivedFactory GetDerivedFactory(Service2 service2);
}
```

以下のように生成される。

```csharp
class BaseFactory
{
	public BaseFactory() { /* ... */ }
	public Client ResolveClient() { /* キャッシュしながら生成 */ }
	public IDerivedFactory GetDerivedFactory(Service2 service2)
	{
		return new DerivedFactory(service2);
	}
}
```

すなわち、元の引数なしの解決メソッドで生成されるコードではユーザーが困るが、それにユーザーは容易に気づくことができることで良しとする。
ユーザーはコンストラクタで`Service2`インスタンスが要求されるのを避けたいと気づいたならば、それを`GetDerivedFactory`解決メソッドの引数に追加するだけでよい。

キャプチャする側は以下のように書く。

```csharp
[Factory]
interface IDerivedFactory : IBaseFactory
{
	ClientB ResolveClientB(Service2 service2);
}
```

これが以下のように生成される。

```csharp
class DerivedFactory : IDerivedFactory
{
	// IDerivedFactory が IBaseFactory を継承している場合に限り、
	// 引数に IBaseFactory を要求する
	public DerivedFactory(IBaseFactory baseFactory, Service2 service2)
	{
		/* 初期化 */
	}
	public Client ResolveClient()
	{
		// キャッシュも含めてキャプチャ元に頼る
		return _baseFactory.ResolveClient();
	}
	public ClientB ResolveClientB()
	{
		return _resolveClientBCache ??= new ClientB(ResolveClient(), _service2);
	}
}
```

このままでは `IBaseFactory` の定義には属性の引数として具象クラスが現れてしまうので、既約ベースで `I` を外した名前のクラスを優先して探すようにしてもよいかもしれない。
とはいえ、DIコンテナとは基本的に抽象と具象が同時に書かれる物なのでそれほど問題はないともいえる。

もしキャプチャー先ファクトリーに自作のファクトリーを注入したければ、`IBaseFactory`インターフェースを以下のように書けばよい：

```csharp
[Factory]
interface IBaseFactory
{
	[Resolution(typeof(DerivedFactory))]
	IDerivedFactory GetDerivedFactory(IBaseFactory baseFactory, Service2 service2);
}
```

こうすることで、`GetDerivedFactory`メソッドを呼び出すユーザー自身が`IBaseFactory`を実装するインスタンスを引数で与える責任を持つことになる。

総じて、この方法でファクトリーを生成する場合に通常の解決メソッドと異なる点は、キャプチャする側がキャプチャ元のファクトリーが持つ解決メソッドを利用するという点のみである。
コード生成としては、依存先インスタンスがファクトリーである場合にその解決メソッドを依存関係の解決手段として考慮に入れるための実装を必要とする。

それから、上記の他の案ではキャッシュがキャプチャ前後で別のスコープとなってしまっていたが、この方法では同じスコープとなる。

||FactoryProvider + Mixin|ファクトリー定義の注入|通常の解決として扱う|
|-|-|-|-|
|キャッシュ問題|問題あり|問題あり|問題なし|
|記述量|属性1 + 継承1|属性2|解決メソッド1 + 継承1|
|手動での生成のしやすさ|しやすい|しづらい|用途による|
|解決メソッドの継承|**継承する**|継承しない|**継承する**|
|解決方法のカスタマイズ|できない|**できる**|**できる**|
|定義に具象を含む|含む|含む|含む|

どれにせよ、Mixin自体は採用すべきであるはず。
ただ、インターフェースの継承関係があってもコンストラクタで要求したくない場合もありそうなので、その対処が必要。

### さらに再考：ミックスインとキャプチャの違い

```csharp
[Factory]
interface IBaseFactory : IFactoryToCapture
{
	[Resolution(typeof(DerivedFactory))]
	IDerivedFactory ResolveDerivedFactory();
}

[Factory]
// 継承を用いて、他のインターフェースをミックスインするか決める
interface IDerivedFactory : IFactoryToMixin
{
	// プロパティを用いて、他のインターフェースをキャプチャするか決める
	// キャプチャすると、コンストラクタでインスタンスを要求する
	// この方法で持っているファクトリー以外のファクトリーは、依存解決に利用しない
	IFactoryToCapture Captured { get; }
}
```

ミックスインはすでにある。

キャプチャは新規実装が必要。

FactoryProvider機能は削減してよさそう。

## オーバーロード解決について

今は戻り値だけで解決メソッドを区別しているが、他の基準が必要か？

キャプチャが絡むと、同じ戻り値を持つ解決メソッドが重複しうる。

また、同じサービスに対して複数の解決メソッドを用意するモチベーションがあるかどうかも考えておきたい。

キャプチャが重複していようと自分の中だけで重複していようとエラーにしてしまうという手もある。

## Dispose呼び出し

キャッシュに対してDisposeを呼び出したい。

## Deprovgenでは検証しないエラーを明確にする

コードが静的に生成されるため、依存解決ができない場合はコンパイルエラーとなる。これがDeprovgenの主な利点である。

コード生成自体ができない場合にのみ、Deprovgenはエラーを起こす。
その場合、Code Fix自体ができないようにするのが良いだろう。
それから、エラーが出る状況に関するドキュメントも欲しい。

生成できないエラーに対して、プレースホルダーのような生成を行って、コメントでエラーを表示するという手もあるかも

## 学習用のコメントを生成する

生成されたコードのいたるところに、「なぜそれが生成されたのか」を示すコメントを生成するようなモードがあるとよいかも？

## 用語の整理

説明としての用語と、クラス名の検討などが必要。

### 用語

* ファクトリー/Factory
* 解決メソッド/Resolver
* 依存関係の解決
	* 解決メソッドの戻り値を受け取ることに対して言う
* 依存関係の注入
	* 解決メソッドの中で行っていることに対して言う
* ファクトリー生成メソッド/Factory provider method
* その場限りのインスタンス/Transient instance
* キャッシュされるインスタンス/Cached instance
* ファクトリー定義/Factory definition
* ファクトリー定義の取り込み/ミックスイン/Factory definition mixin
* 依存先オブジェクト/Dependencies
	* あるファクトリーが、自身の解決メソッドで必要とするが解決メソッドでは生成できないオブジェクト。コンストラクタを通じて与える必要がある
* ファクトリーのキャプチャ/Facotry capturing
	* あるファクトリーが、他のファクトリーのファクトリー生成メソッドによって生成される時、前者のファクトリーが後者をキャプチャしているという。

する・される

* キャプチャーする
* キャプチャーされる
* ミックスインする
* ミックスインされる

### クラス名・メソッド名

属性

* Factory
* FactoryProvider
* ConfigureGenericHost
* Implementation
	* 1つのメソッドに複数つく可能性も考えると長い。`Resolution`とかがよい？

# 開発方針

## コードの構造

「こういう文法の場合は解決メソッドの解析をする」というふうに文法を検知する部分と、
「文法を元に定義を取り出す」ような定義を解析する部分を分けたい

* `xxSource` : 文法を見つける機能を持つクラス
* `xxAnalyzer` : 見つけた部分を元に定義を作るクラス
* `xxDefinition` : テンプレートに渡すデータ

「解決メソッドで生成できるサービスは依存関係に含まない」などの相互作用もあるため注意が必要。

以下のような文法が存在する。

### ファクトリー

必要な情報：Factory属性のついたインターフェース

### 解決メソッド

必要な情報：Ignore属性のついていないメソッドで、コレクション解決メソッドとして解釈されないもの

### 依存関係

必要な情報

* 解決メソッドの戻り値の型が持つコンストラクタの引数
* 解決メソッドについているResolutionの引数に指定された型が持つコンストラクタの引数
* 解決メソッドの戻り値の型リスト
* 解決メソッドのパラメーター
* キャプチャしている型

### ミックスイン

インターフェースを継承している場合は、基底インターフェースのメソッドもResolverとして解析する。

必要な情報

* ファクトリーとなるインターフェースで、他のインターフェースを継承していて、その基底インターフェースもファクトリーであるもの

### キャプチャ

必要な情報

* get-onlyなプロパティで、プロパティの型もファクトリー定義インターフェースであるもの

### コレクション解決メソッド

必要な情報

* Ignore属性のついていないメソッドで、戻り値がIEnumerable&lt;T>であり、Resolution属性がついていて、Resolution属性の引数に指定された型がTから派生しているもの